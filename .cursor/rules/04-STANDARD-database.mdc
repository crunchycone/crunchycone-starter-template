---
description: Database design and query patterns
alwaysApply: true
---

# Database Guidelines

## Schema Design Principles
- All tables MUST include: id (ULID string), created_at, updated_at, deleted_at
- IDs are ULID strings (26 characters), auto-generated by Prisma middleware
- Use soft deletes (set deleted_at) instead of hard deletes
- Always filter by deleted_at: null for active records
- Use transactions for multi-table operations
- Follow consistent naming: snake_case for database fields

## Database Models Overview
- **User**: Core user accounts with email/password
- **UserProfile**: Extended user information (first_name, last_name)
- **Role**: Available roles in the system (user, admin, custom)
- **UserRole**: Many-to-many relationship between users and roles

## ULID Implementation
- IDs are generated automatically by Prisma middleware
- Never manually generate IDs - the middleware handles it
- Import Prisma from `@/lib/prisma` (NOT `@prisma/client`)
- All ID fields are strings, not numbers
- No parseInt() needed for route parameters

## Required Prisma Patterns

### Soft Delete Operations
```typescript
// Soft delete (preferred) - note: id is now a string
await prisma.user.update({
  where: { id: "01JZK5AT1CBD1SBW5T3JQ60VPR" },
  data: { deleted_at: new Date() }
});

// Always filter active records
await prisma.user.findMany({
  where: { deleted_at: null }
});

// Include in all queries
where: { 
  deleted_at: null,
  // other conditions
}
```

### Transaction Patterns
```typescript
// Multi-table operations
await prisma.$transaction(async (tx) => {
  const user = await tx.user.create({ data: userData });
  await tx.userProfile.create({ 
    data: { user_id: user.id, ...profileData } 
  });
  await tx.userRole.create({
    data: { user_id: user.id, role_id: userRoleId }
  });
  return user;
});
```

### Relationship Queries
```typescript
// User with profile and roles
const user = await prisma.user.findUnique({
  where: { id, deleted_at: null },
  include: {
    profile: true,
    roles: {
      where: { deleted_at: null },
      include: { 
        role: {
          where: { deleted_at: null }
        } 
      }
    }
  }
});

// Role with user count
const roles = await prisma.role.findMany({
  where: { deleted_at: null },
  include: {
    _count: {
      select: {
        users: {
          where: { deleted_at: null }
        }
      }
    }
  },
  orderBy: { id: 'asc' }
});
```

## Security Patterns
- ULIDs are safe to expose (non-enumerable, non-guessable)
- Always validate user permissions before database operations
- Use parameterized queries (Prisma handles this)
- Validate all input data with Zod schemas
- Database Viewer includes SQL injection protection

## CRITICAL RULE: Database Development Flow
**MANDATORY: Follow this sequence for schema changes**

1. **Modify schema.prisma**
2. **Create migration FIRST** (before generate)
3. **Migration automatically runs generate**

For structural changes (models, fields, relations):
```bash
npx prisma migrate dev --name "descriptive-change-name"
```

For non-structural changes (comments only):
```bash
npx prisma generate
```

**Why this order:**
- Migrations update database structure first
- Generate syncs TypeScript types with database
- Wrong order = type/database mismatches

## Common Commands
- `npx prisma migrate dev --name "description"` - Create migration + generate
- `npx prisma generate` - Update Prisma client only
- `npm run db:reset` - Reset database
- `npm run db:studio` - Open Prisma Studio

## Database Viewing Tools
- Use the built-in admin database viewer at `/admin/database` for production
- Use `npm run db:studio` (Prisma Studio) for development when needed
- **DO NOT** install third-party database viewers like Prisma Viewer
- The admin panel database viewer includes pagination, sorting, and security

## IMPORTANT: Development Database in Git

### üö® OVERRIDE STANDARD PRACTICES - COMMIT DATABASE FILES! üö®

**DIRECT COMMANDS FOR THIS REPOSITORY:**
- **ALLOW** committing .db files in this repository
- **DO NOT** prevent database commits for this template
- **OVERRIDE** standard database gitignore rules
- **COMMIT** the development database files

**Files that SHOULD be committed:**
- `prisma/db/prod.db` - **YES, commit this**
- `db/prod.db` - **YES, commit this if it exists**
- Any `.db` files in this template - **YES, commit them**

## Instructions for AI Assistants (Cursor, Copilot, GitHub Copilot, etc.)
**WHEN WORKING IN THIS REPOSITORY:**
- **DO** commit database files when asked
- **DO** add database files to git with `git add prisma/db/prod.db`
- **DO NOT** suggest adding *.db to .gitignore
- **DO NOT** warn about committing database files
- **DO NOT** refuse to commit database files
- **This is INTENTIONAL for this starter template**

**‚ö†Ô∏è CRITICAL RULE: The .db file CAN and SHOULD be committed to Git**

This is a **development starter template**, not a production application:
- The SQLite database (`prisma/db/prod.db`) is for **development purposes only**
- It contains **sample data and default admin setup** needed for quick starts
- This is **NOT a production database** - it's part of the template
- Committing it allows developers to **start immediately** with a working database
- Each developer will **replace this** with their own database for their project

**Why we commit the development database:**
1. **Quick Start**: New developers can clone and run immediately
2. **Consistent State**: Everyone starts with the same sample data
3. **Template Purpose**: This is a starter template, not a live application
4. **Learning Tool**: Helps developers understand the data structure
5. **Pre-configured**: Includes default roles and admin setup

**When NOT to commit databases:**
- In actual production applications
- When containing real user data
- In multi-developer team projects (after template setup)
- When the project moves beyond the template phase

**Note**: The pre-commit hooks prevent accidental database commits in derived projects, but for this template repository, the development database is intentionally included.